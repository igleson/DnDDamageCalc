<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>"D&D Damage Calculator"</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
    <link rel="stylesheet" href="/style.css" />
    <script src="https://unpkg.com/htmx.org@2.0.4"
            integrity="sha384-HGfztofotfshcF7+8n44JQL2oJmowVChPTg48S+jvZoztPfvwD79OC/LTtG6dMp+"
            crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
        }
        .app-layout {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            min-width: 280px;
            background: var(--pico-card-background-color);
            border-right: 1px solid var(--pico-muted-border-color);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            transition: margin-left 0.25s ease;
            overflow-y: auto;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        .sidebar.collapsed {
            margin-left: -280px;
        }
        .sidebar h4 {
            margin-bottom: 0.5rem;
        }
        .sidebar-sections {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .sidebar-section {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .sidebar-divider {
            height: 1px;
            margin: 0.75rem 0;
            background: var(--pico-primary);
            flex-shrink: 0;
        }
        #character-list,
        #encounter-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Toggle button */
        .sidebar-toggle {
            position: fixed;
            top: 0.75rem;
            left: 0.75rem;
            z-index: 10;
            width: auto !important;
            padding: 0.35rem 0.65rem !important;
            margin: 0 !important;
            font-size: 1.2rem;
            line-height: 1;
            transition: left 0.25s ease;
        }
        .collapse-all-toggle {
            position: fixed;
            top: 0.75rem;
            right: 1.5rem;
            z-index: 10;
            background: var(--pico-primary);
            border-color: var(--pico-primary);
            color: var(--pico-primary-inverse);
        }
        .collapse-all-toggle:hover {
            background: var(--pico-primary-hover);
            border-color: var(--pico-primary-hover);
        }
        .sidebar:not(.collapsed) ~ .app-main .sidebar-toggle {
            left: 290px;
        }

        /* Main content */
        .app-main {
            flex: 1;
            min-width: 0;
            padding: 1rem 2rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }
        header.app-header {
            text-align: center;
            padding: 1rem 0;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--pico-muted-border-color);
            width: 100%;
            max-width: 700px;
        }
        header.app-header h1 {
            margin-bottom: 0.25rem;
        }
        header.app-header small {
            color: var(--pico-muted-color);
        }

        #form-container {
            width: 100%;
            max-width: 700px;
        }

        /* Form styles */
        #form-container fieldset {
            border: 1px solid var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            padding: 1rem;
            margin-bottom: 1rem;
        }
        #form-container fieldset legend {
            font-weight: bold;
            padding: 0 0.5rem;
        }
        .attack-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .attack-draggable {
            transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease, opacity 0.12s ease;
        }
        .attack-draggable.dragging {
            opacity: 0.5;
            transform: scale(0.99);
            box-shadow: 0 0 0 2px var(--pico-primary);
        }
        .attack-draggable.drop-above {
            border-top: 3px solid var(--pico-primary);
        }
        .attack-draggable.drop-below {
            border-bottom: 3px solid var(--pico-primary);
        }
        .drag-handle {
            cursor: grab;
        }
        .drag-handle:active {
            cursor: grabbing;
        }
        .btn-sm {
            width: auto !important;
            margin: 0 !important;
            padding: 0.25rem 0.75rem !important;
        }

        /* Sidebar character items */
        .char-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            border-radius: var(--pico-border-radius);
            margin-bottom: 0.25rem;
            min-width: 0; /* Allow flex children to shrink below their content size */
        }
        .char-item:hover {
            background: var(--pico-secondary-hover-background);
        }
        .char-item a {
            flex: 1;
            text-decoration: none;
            min-width: 0; /* Allow text to shrink */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 0.5rem; /* Space between name and delete button */
        }
        .char-item .btn-sm {
            flex-shrink: 0; /* Prevent delete button from shrinking */
            min-width: auto;
            padding: 0.25rem 0.5rem !important; /* Smaller padding for delete button */
        }

        /* Responsive: stack on small screens */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                z-index: 5;
                box-shadow: 2px 0 8px rgba(0,0,0,0.3);
            }
            .sidebar.collapsed {
                margin-left: -280px;
            }
            .sidebar-toggle {
                left: 0.75rem !important;
            }
            .sidebar:not(.collapsed) ~ .app-main .sidebar-toggle {
                left: 290px !important;
            }
            .app-main {
                padding: 1rem;
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-sections">
                <section class="sidebar-section">
                    <h4>Characters</h4>
                    <div id="character-list">
                        {{ character_list.html }}
                    </div>
                    <button type="button" class="outline"
                            hx-get="/character/form"
                            hx-target="#form-container"
                            hx-swap="innerHTML"
                            style="width:100%;">
                        + New Character
                    </button>
                </section>

                <div class="sidebar-divider"></div>

                <section class="sidebar-section">
                    <h4>Encounters</h4>
                    <div id="encounter-list">
                        {{ encounter_list.html }}
                    </div>
                    <button type="button" class="outline"
                            hx-get="/encounter/form"
                            hx-target="#form-container"
                            hx-swap="innerHTML"
                            style="width:100%;">
                        + New Encounter
                    </button>
                </section>
            </div>
            {{ if show_logout }}
            <hr />
            <form method="post" action="/auth/logout">
                <button type="submit" class="outline secondary" style="width:100%;">Logout</button>
            </form>
            {{ end }}
        </aside>

        <div class="app-main">
            <button type="button" class="sidebar-toggle outline secondary"
                    onclick="document.getElementById('sidebar').classList.toggle('collapsed')">
                &#9776;
            </button>
            <button type="button"
                    class="collapse-all-toggle btn-sm"
                    onclick="collapseCharacterFormSections()">
                Collapse All
            </button>

            <header class="app-header">
                <h1>D&D Damage Calculator</h1>
                <small>Build your character, calculate your damage</small>
            </header>

            <div id="messages"></div>

            <div id="form-container">
                {{ character_form.html }}
            </div>
        </div>
    </div>
    <script>
        function addEncounterCombat() {
            const combatsContainer = document.getElementById('encounter-combats');
            if (!combatsContainer) return;
            const newIndex = combatsContainer.querySelectorAll('article[id^="combat-"]').length;
            const wrapper = document.createElement('article');
            wrapper.id = `combat-${newIndex}`;
            wrapper.style.padding = '0.6rem';
            wrapper.style.margin = '0.5rem 0';
            wrapper.innerHTML = `
                <label>Combat ${newIndex + 1} Rounds</label>
                <input type="number" min="1" name="combat[${newIndex}].rounds" value="1" required />
                <label>
                    <input type="checkbox" name="combat[${newIndex}].shortRestAfter" />
                    Short rest after this combat
                </label>
                <button type="button" class="outline secondary btn-sm" onclick="removeEncounterCombat('combat-${newIndex}')">Remove Combat</button>
            `;
            combatsContainer.appendChild(wrapper);
        }

        function removeEncounterCombat(id) {
            const element = document.getElementById(id);
            if (!element) return;
            element.remove();
        }

        function graphContainerFromElement(element) {
            return element.closest('[data-damage-graph]');
        }

        function toggleSectionById(button) {
            const targetId = button.getAttribute('data-collapse-target');
            if (!targetId) return;

            const target = document.getElementById(targetId);
            if (!target) return;

            const shouldExpand = target.style.display === 'none';
            target.style.display = shouldExpand ? '' : 'none';
            button.textContent = shouldExpand ? '\u25BE' : '\u25B8';
        }

        function collapseCharacterFormSections() {
            const form = document.getElementById('character-form');
            if (!form) return;

            form.querySelectorAll('[data-collapse-target]').forEach((button) => {
                const targetId = button.getAttribute('data-collapse-target');
                if (!targetId) return;

                const target = document.getElementById(targetId);
                if (!target || target.style.display === 'none') return;

                target.style.display = 'none';
                button.textContent = '\u25B8';
            });
        }

        function moveDamageTooltip(event) {
            const point = event.currentTarget;
            const graph = graphContainerFromElement(point);
            if (!graph) return;

            const tooltip = graph.querySelector('[data-damage-tooltip]');
            if (!tooltip || tooltip.dataset.visible !== 'true') return;

            const graphRect = graph.getBoundingClientRect();
            let left = event.clientX - graphRect.left + 12;
            let top = event.clientY - graphRect.top - 30;

            const maxLeft = graph.clientWidth - tooltip.offsetWidth - 8;
            const maxTop = graph.clientHeight - tooltip.offsetHeight - 8;
            left = Math.max(8, Math.min(left, maxLeft));
            top = Math.max(8, Math.min(top, maxTop));

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        function showDamageTooltip(event) {
            const point = event.currentTarget;
            const graph = graphContainerFromElement(point);
            if (!graph) return;

            const tooltip = graph.querySelector('[data-damage-tooltip]');
            if (!tooltip) return;

            const stat = point.getAttribute('data-stat-label');
            const level = point.getAttribute('data-level');
            const damage = point.getAttribute('data-damage');
            tooltip.textContent = `${stat} - Level ${level}: ${damage}`;
            tooltip.dataset.series = point.getAttribute('data-series') || '';
            tooltip.dataset.visible = 'true';
            tooltip.style.display = 'block';
            moveDamageTooltip(event);
        }

        function hideDamageTooltip(element) {
            const graph = graphContainerFromElement(element);
            if (!graph) return;

            const tooltip = graph.querySelector('[data-damage-tooltip]');
            if (!tooltip) return;

            tooltip.dataset.visible = 'false';
            tooltip.dataset.series = '';
            tooltip.style.display = 'none';
        }

        function toggleDamageSeries(toggle) {
            const graph = toggle.closest('[data-damage-graph]');
            if (!graph) return;

            const key = toggle.getAttribute('data-series-toggle');
            if (!key) return;

            graph.querySelectorAll(`[data-series="${key}"]`).forEach(el => {
                el.style.display = toggle.checked ? '' : 'none';
            });

            if (!toggle.checked) {
                const tooltip = graph.querySelector('[data-damage-tooltip]');
                if (tooltip && tooltip.dataset.series === key) {
                    hideDamageTooltip(toggle);
                }
            }
        }

        // Handle 401 unauthorized responses
        document.addEventListener('htmx:responseError', function(e) {
            if (e.detail.xhr.status === 401) window.location.href = '/login';
        });

        // Track selected character in sidebar
        document.addEventListener('htmx:beforeRequest', function(evt) {
            const target = evt.detail.elt;
            
            // If clicking a character link
            if (target.hasAttribute('hx-get') && target.getAttribute('hx-get').startsWith('/character/')) {
                const charItem = target.closest('.char-item');
                if (charItem) {
                    // Remove selected class from all items
                    document.querySelectorAll('.char-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    // Add selected class to clicked item
                    charItem.classList.add('selected');
                }
            }
            
            // If clicking "New Character" button
            if (target.hasAttribute('hx-get') && target.getAttribute('hx-get') === '/character/form') {
                // Remove selected class from all character items
                document.querySelectorAll('.char-item').forEach(item => {
                    item.classList.remove('selected');
                });
            }
        });

        // URL Management for Character Routing
        
        // Utility functions for URL parsing
        function getCurrentCharacterId() {
            const match = window.location.pathname.match(/^\/character\/(\d+)$/);
            return match ? parseInt(match[1]) : null;
        }
        
        function isNewCharacterUrl() {
            return window.location.pathname === '/';
        }
        
        function updateUrlForCharacter(characterId) {
            const newUrl = `/character/${characterId}`;
            if (window.location.pathname !== newUrl) {
                history.pushState({ characterId }, '', newUrl);
            }
        }
        
        function updateUrlForNewCharacter() {
            const newUrl = '/';
            if (window.location.pathname !== newUrl) {
                history.pushState({ newCharacter: true }, '', newUrl);
            }
        }
        
        // Handle successful character loads and update URL
        document.addEventListener('htmx:afterSwap', function(evt) {
            const target = evt.detail.elt;
            
            // Check if this was a character form load
            if (target && target.id === 'form-container') {
                const xhr = evt.detail.xhr;
                const requestUrl = evt.detail.requestConfig?.path || xhr?.responseURL;
                
                if (requestUrl) {
                    // Check if this was a character load
                    const characterMatch = requestUrl.match(/\/character\/(\d+)$/);
                    if (characterMatch) {
                        const characterId = parseInt(characterMatch[1]);
                        updateUrlForCharacter(characterId);
                    }
                    // Check if this was a new character form load
                    else if (requestUrl.includes('/character/form')) {
                        updateUrlForNewCharacter();
                    }
                }
            }
            
            // Check if this was a character deletion (character list update)
            if (target && target.id === 'character-list') {
                // If we're currently viewing a character that was potentially deleted,
                // and the character is no longer in the list, redirect to home
                const currentCharId = getCurrentCharacterId();
                if (currentCharId) {
                    const characterStillExists = target.querySelector(`a[hx-get="/character/${currentCharId}"]`);
                    if (!characterStillExists) {
                        // Character was deleted, update URL to home and load new character form
                        updateUrlForNewCharacter();
                        const newCharacterBtn = document.querySelector('button[hx-get="/character/form"]');
                        if (newCharacterBtn) {
                            htmx.trigger(newCharacterBtn, 'click');
                        }
                    }
                }
            }
        });
        
        // Handle browser back/forward navigation
        window.addEventListener('popstate', function(evt) {
            const currentCharId = getCurrentCharacterId();
            
            if (currentCharId) {
                // Load character by ID
                const characterLink = document.querySelector(`a[hx-get="/character/${currentCharId}"]`);
                if (characterLink) {
                    // Trigger HTMX request to load the character
                    htmx.trigger(characterLink, 'click');
                } else {
                    // Character not found in sidebar, redirect to home
                    window.location.href = '/';
                }
            } else if (isNewCharacterUrl()) {
                // Load new character form
                const newCharacterBtn = document.querySelector('button[hx-get="/character/form"]');
                if (newCharacterBtn) {
                    htmx.trigger(newCharacterBtn, 'click');
                }
            }
        });

        // Initialize URL state on page load
        function initializeUrlState() {
            // Ensure sidebar selection matches current URL
            const currentCharId = getCurrentCharacterId();
            if (currentCharId) {
                // Mark the current character as selected in the sidebar
                const characterLink = document.querySelector(`a[hx-get="/character/${currentCharId}"]`);
                if (characterLink) {
                    const charItem = characterLink.closest('.char-item');
                    if (charItem) {
                        document.querySelectorAll('.char-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        charItem.classList.add('selected');
                    }
                }
            }
        }
        
        // Run initialization when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeUrlState();
            initializeLevelTemplate();
            initializeAttackTemplate();
        });
        // Also run after HTMX settles (in case page was loaded via HTMX)
        document.addEventListener('htmx:afterSettle', initializeUrlState);

        function copyFormControlState(sourceRoot, clonedRoot) {
            const sourceControls = sourceRoot.querySelectorAll('input, select, textarea');
            const clonedControls = clonedRoot.querySelectorAll('input, select, textarea');
            const count = Math.min(sourceControls.length, clonedControls.length);

            for (let i = 0; i < count; i++) {
                const source = sourceControls[i];
                const cloned = clonedControls[i];

                if (source instanceof HTMLInputElement && cloned instanceof HTMLInputElement) {
                    if (source.type === 'checkbox' || source.type === 'radio') {
                        cloned.checked = source.checked;
                    } else {
                        cloned.value = source.value;
                    }
                } else if (source instanceof HTMLSelectElement && cloned instanceof HTMLSelectElement) {
                    cloned.value = source.value;
                } else if (source instanceof HTMLTextAreaElement && cloned instanceof HTMLTextAreaElement) {
                    cloned.value = source.value;
                }
            }
        }

        let draggedAttackElement = null;

        function clearAttackDropIndicators(container) {
            if (!container) return;
            container.querySelectorAll('.drop-above, .drop-below').forEach(el => {
                el.classList.remove('drop-above', 'drop-below');
            });
        }

        function updateAttackOrderForLevel(levelIndex) {
            const container = document.getElementById(`attacks-${levelIndex}`);
            if (!container) return;

            const attacks = container.querySelectorAll('fieldset[id^="attack-"]');
            attacks.forEach((attack, order) => {
                const orderInput = attack.querySelector('input[name$=".order"]');
                if (orderInput) {
                    orderInput.value = order.toString();
                }
            });
        }

        function onAttackDragStart(event) {
            const attack = event.currentTarget;
            if (!(attack instanceof HTMLElement)) return;
            draggedAttackElement = attack;
            attack.classList.add('dragging');
            if (event.dataTransfer) {
                event.dataTransfer.effectAllowed = 'move';
                event.dataTransfer.setData('text/plain', attack.id);
            }
        }

        function onAttackDragOver(event) {
            event.preventDefault();
            const dropTarget = event.currentTarget;
            if (!(dropTarget instanceof HTMLElement) || !draggedAttackElement || dropTarget === draggedAttackElement) return;

            const container = dropTarget.parentElement;
            if (!container) return;
            clearAttackDropIndicators(container);

            const rect = dropTarget.getBoundingClientRect();
            const insertBefore = event.clientY < rect.top + (rect.height / 2);
            dropTarget.classList.add(insertBefore ? 'drop-above' : 'drop-below');

            const nextSibling = insertBefore ? dropTarget : dropTarget.nextElementSibling;
            if (nextSibling !== draggedAttackElement) {
                container.insertBefore(draggedAttackElement, nextSibling);
                const levelMatch = container.id.match(/^attacks-(\d+)$/);
                if (levelMatch) {
                    updateAttackOrderForLevel(parseInt(levelMatch[1], 10));
                }
            }

            if (event.dataTransfer) {
                event.dataTransfer.dropEffect = 'move';
            }
        }

        function onAttackDragLeave(event) {
            const dropTarget = event.currentTarget;
            if (!(dropTarget instanceof HTMLElement)) return;
            if (dropTarget.contains(event.relatedTarget)) return;
            dropTarget.classList.remove('drop-above', 'drop-below');
        }

        function onAttackDrop(event) {
            event.preventDefault();
            const dropTarget = event.currentTarget;
            if (!(dropTarget instanceof HTMLElement) || !draggedAttackElement) return;
            const container = draggedAttackElement.parentElement;
            if (!container) return;
            clearAttackDropIndicators(container);
            const levelMatch = container.id.match(/^attacks-(\d+)$/);
            if (levelMatch) {
                updateAttackOrderForLevel(parseInt(levelMatch[1], 10));
            }
        }

        function onAttackDragEnd(event) {
            const attack = event.currentTarget;
            if (attack instanceof HTMLElement) {
                attack.classList.remove('dragging');
                clearAttackDropIndicators(attack.parentElement);
            }
            draggedAttackElement = null;
        }

        // Clone attack function - pure client-side
        function cloneAttack(levelIndex) {
            const container = document.getElementById(`attacks-${levelIndex}`);
            if (!container) return;
            
            const attacks = container.querySelectorAll('fieldset');
            if (attacks.length === 0) return;
            
            // Clone the last attack
            const lastAttack = attacks[attacks.length - 1];
            const cloned = lastAttack.cloneNode(true);
            copyFormControlState(lastAttack, cloned);
            
            // Get current counter and increment
            const counterInput = document.getElementById('attack-counter');
            const currentCounter = parseInt(counterInput.value) || attacks.length;
            const newIndex = currentCounter;
            cloned.id = `attack-${levelIndex}-${newIndex}`;
            
            // Find the old attack index from the last attack's id attribute
            const lastAttackId = lastAttack.id;
            const oldIndexMatch = lastAttackId.match(/attack-\d+-(\d+)$/);
            const oldIndex = oldIndexMatch ? parseInt(oldIndexMatch[1]) : attacks.length - 1;
            
            // Find the old level index from the last attack's name attribute
            const sampleInput = lastAttack.querySelector('[name]');
            const oldLevelIndex = sampleInput && sampleInput.name ? 
                (sampleInput.name.match(/level\[(\d+)\]/) || [null, levelIndex])[1] : levelIndex;
            
            // Update all name attributes: level[oldLevelIndex].attacks[oldIndex] -> level[levelIndex].attacks[newIndex]
            cloned.querySelectorAll('[name]').forEach(input => {
                if (input.name) {
                    input.name = input.name
                        .replace(`level[${oldLevelIndex}]`, `level[${levelIndex}]`)
                        .replace(`attacks[${oldIndex}]`, `attacks[${newIndex}]`);
                }
            });
            
            // Update all id attributes: attack-{level}-{oldIndex} -> attack-{level}-{newIndex}
            cloned.querySelectorAll('[id]').forEach(el => {
                if (el.id) {
                    el.id = el.id.replace(
                        new RegExp(`-${levelIndex}-${oldIndex}(-|$)`, 'g'),
                        `-${levelIndex}-${newIndex}$1`
                    );
                }
            });
            
            // Update HTMX attributes (hx-target, hx-delete, hx-post)
            cloned.querySelectorAll('[hx-target]').forEach(el => {
                const target = el.getAttribute('hx-target');
                if (target) {
                    el.setAttribute('hx-target', target.replace(
                        `-${levelIndex}-${oldIndex}`,
                        `-${levelIndex}-${newIndex}`
                    ));
                }
            });
            
            cloned.querySelectorAll('[hx-delete]').forEach(el => {
                const url = el.getAttribute('hx-delete');
                if (url) {
                    el.setAttribute('hx-delete', url.replace(
                        `attackIndex=${oldIndex}`,
                        `attackIndex=${newIndex}`
                    ));
                }
            });
            
            cloned.querySelectorAll('[hx-post]').forEach(el => {
                const url = el.getAttribute('hx-post');
                if (url) {
                    el.setAttribute('hx-post', url.replace(
                        `attackIndex=${oldIndex}`,
                        `attackIndex=${newIndex}`
                    ));
                }
            });

            cloned.querySelectorAll('[data-collapse-target]').forEach(el => {
                const targetId = el.getAttribute('data-collapse-target');
                if (targetId) {
                    el.setAttribute('data-collapse-target', targetId.replace(
                        `-${levelIndex}-${oldIndex}`,
                        `-${levelIndex}-${newIndex}`
                    ));
                }
            });

            cloned.querySelectorAll('[data-collapse-target]').forEach(toggle => {
                const targetId = toggle.getAttribute('data-collapse-target');
                if (!targetId) return;

                const target = cloned.querySelector(`[id="${targetId}"]`);
                if (target) {
                    target.style.display = '';
                }

                toggle.textContent = '\u25BE';
            });

            // Update onclick handlers that still reference old attack index/ids
            cloned.querySelectorAll('[onclick]').forEach(btn => {
                const onclickStr = btn.getAttribute('onclick');
                if (!onclickStr) return;

                let updatedOnclick = onclickStr;
                updatedOnclick = updatedOnclick.replace(
                    new RegExp(`addDice\\(${oldLevelIndex},\\s*${oldIndex}\\)`, 'g'),
                    `addDice(${levelIndex}, ${newIndex})`
                );
                updatedOnclick = updatedOnclick.replace(
                    new RegExp(`removeAttack\\('attack-${oldLevelIndex}-${oldIndex}'\\)`, 'g'),
                    `removeAttack('attack-${levelIndex}-${newIndex}')`
                );
                updatedOnclick = updatedOnclick.replace(
                    new RegExp(`removeDice\\('dice-${oldLevelIndex}-${oldIndex}-`, 'g'),
                    `removeDice('dice-${levelIndex}-${newIndex}-`
                );

                btn.setAttribute('onclick', updatedOnclick);
            });
             
            // Update the counter
            counterInput.value = newIndex + 1;
            
            // Append to container
            container.appendChild(cloned);
            updateAttackOrderForLevel(levelIndex);
             
            // Process HTMX attributes on the new element
            htmx.process(cloned);
        }

        // Template caching for JavaScript level creation
        let emptyLevelTemplate = null;

        function initializeLevelTemplate() {
            // Create a temporary empty level to use as template
            if (emptyLevelTemplate) return;
            
            // Use the server-rendered template structure
            emptyLevelTemplate = `
                <article id="LEVEL_ID_PLACEHOLDER">
                    <header>
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <strong>Level LEVEL_NUMBER_PLACEHOLDER</strong>
                            <div style="display:flex;gap:0.5rem;">
                                <button type="button"
                                        data-collapse-target="LEVEL_BODY_ID_PLACEHOLDER"
                                        onclick="toggleSectionById(this)"
                                        class="outline secondary btn-sm">&#x25BE;</button>
                                <button type="button"
                                        onclick="removeLevel('LEVEL_ID_PLACEHOLDER')"
                                        class="outline secondary btn-sm">
                                    Remove Level
                                </button>
                            </div>
                        </div>
                    </header>

                    <input type="hidden" name="level[LEVEL_INDEX_PLACEHOLDER].number" value="LEVEL_NUMBER_PLACEHOLDER" />

                    <div id="LEVEL_BODY_ID_PLACEHOLDER">
                        <fieldset id="resources-LEVEL_INDEX_PLACEHOLDER">
                            <legend style="display:flex;align-items:center;gap:0.5rem;">
                                <button type="button"
                                        data-collapse-target="RESOURCES_BODY_ID_PLACEHOLDER"
                                        onclick="toggleSectionById(this)"
                                        class="outline secondary btn-sm">&#x25BE;</button>
                                Resources
                            </legend>
                            <div id="RESOURCES_BODY_ID_PLACEHOLDER">
                                <input type="hidden"
                                       name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasActionSurge"
                                       value="false" />
                                <label>
                                    <input type="checkbox"
                                           name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasActionSurge"
                                           value="true" />
                                    Action Surge
                                </label>
                                <label>
                                    <input type="checkbox"
                                           name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasExtraActionSurge"
                                           onchange="this.closest('label').querySelector('.extra-action-surge-value').value=this.checked?'true':'false'"
                                           value="true" />
                                    Extra Action Surge
                                    <input type="hidden"
                                           class="extra-action-surge-value"
                                           name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasExtraActionSurgeValue"
                                           value="false" />
                                </label>
                                <input type="hidden"
                                       name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasShieldMaster"
                                       value="false" />
                                <label>
                                    <input type="checkbox"
                                           name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasShieldMaster"
                                           value="true"
                                           onchange="this.closest('fieldset').querySelector('.shield-master-topple').style.display=this.checked?'block':'none'" />
                                    Shield Master
                                </label>
                                <div class="shield-master-topple" style="display:none;">
                                    <label for="level[LEVEL_INDEX_PLACEHOLDER].resources.shieldMasterTopplePercent">Shield Master Topple %</label>
                                    <input type="number"
                                           name="level[LEVEL_INDEX_PLACEHOLDER].resources.shieldMasterTopplePercent"
                                           value="0"
                                           min="0"
                                           max="100" />
                                </div>
                                <input type="hidden"
                                       name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasHeroicInspiration"
                                       value="false" />
                                <label>
                                    <input type="checkbox"
                                           name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasHeroicInspiration"
                                           value="true" />
                                    Heroic Inspiration
                                </label>
                                <input type="hidden"
                                       name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasStudiedAttacks"
                                       value="false" />
                                <label>
                                    <input type="checkbox"
                                           name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasStudiedAttacks"
                                           value="true" />
                                    Studied Attacks
                                </label>
                                <input type="hidden"
                                       name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasBoonOfCombatProwess"
                                       value="false" />
                                <label>
                                    <input type="checkbox"
                                           name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasBoonOfCombatProwess"
                                           value="true" />
                                    Boon of Combat Prowess
                                </label>
                                <input type="hidden"
                                       name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasPureAdvantage"
                                       value="false" />
                                <label>
                                    <input type="checkbox"
                                           name="level[LEVEL_INDEX_PLACEHOLDER].resources.hasPureAdvantage"
                                           value="true"
                                           onchange="this.closest('fieldset').querySelector('.pure-advantage-pct').style.display=this.checked?'block':'none'" />
                                    Pure Advantage
                                </label>
                                <div class="pure-advantage-pct" style="display:none;">
                                    <label for="level[LEVEL_INDEX_PLACEHOLDER].resources.pureAdvantagePercent">Pure Advantage %</label>
                                    <input type="number"
                                           name="level[LEVEL_INDEX_PLACEHOLDER].resources.pureAdvantagePercent"
                                           value="0"
                                           min="0"
                                           max="100" />
                                </div>
                            </div>
                        </fieldset>

                        <div id="attacks-LEVEL_INDEX_PLACEHOLDER">
                            <!-- Empty attacks container -->
                        </div>

                        <div style="display:flex;gap:1rem;">
                            <button type="button"
                                    onclick="addAttack(LEVEL_INDEX_PLACEHOLDER)"
                                    class="outline btn-sm">
                                + Add Attack
                            </button>
                        </div>
                    </div>
                </article>
            `;
        }

        // Add level function - pure client-side
        function addLevel() {
            const container = document.getElementById('levels-container');
            if (!container) return;
            
            // Initialize template if not already done
            initializeLevelTemplate();
            if (!emptyLevelTemplate) return;
            
            // Get current level counter for unique IDs (monotonic)
            const levelCounter = document.getElementById('level-counter');
            if (!levelCounter) return;
            
            const currentCounter = parseInt(levelCounter.value) || 0;
            const newIndex = currentCounter; // For unique IDs
            
            // Calculate level number based on existing levels count + 1
            const existingLevels = container.children.length;
            const newLevelNumber = existingLevels + 1;
            
            // Validate maximum level
            if (newLevelNumber > 20) {
                alert('Maximum level is 20');
                return;
            }
            
            // Create new level HTML by replacing placeholders
            const levelId = 'level-' + newIndex;
            const levelBodyId = 'level-body-' + newIndex;
            const resourcesBodyId = 'resources-body-' + newIndex;
             
            let levelHtml = emptyLevelTemplate
                .replace(/LEVEL_ID_PLACEHOLDER/g, levelId)
                .replace(/LEVEL_BODY_ID_PLACEHOLDER/g, levelBodyId)
                .replace(/RESOURCES_BODY_ID_PLACEHOLDER/g, resourcesBodyId)
                .replace(/LEVEL_INDEX_PLACEHOLDER/g, newIndex.toString())
                .replace(/LEVEL_NUMBER_PLACEHOLDER/g, newLevelNumber.toString());
            
            // Create a temporary div to hold the HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = levelHtml;
            const newLevel = tempDiv.firstElementChild;
            
            if (!newLevel) return;
            
            // Update the level counter
            levelCounter.value = newIndex + 1;
            
            // Show clone button if this is the first level
            const cloneButtonSpan = document.getElementById('clone-level-btn');
            if (cloneButtonSpan && container.children.length === 0) {
                cloneButtonSpan.innerHTML = '<button type="button" onclick="cloneLevel()" class="secondary outline">Clone Last Level</button>';
            }
            
            // Append to container
            container.appendChild(newLevel);
            
            // Process HTMX attributes on the new element
            htmx.process(newLevel);
        }

        // Renumber all levels to maintain sequential order (1, 2, 3, etc.)
        function renumberAllLevels() {
            const container = document.getElementById('levels-container');
            if (!container) return;
            
            const levels = container.querySelectorAll('article[id^="level-"]');
            levels.forEach((level, index) => {
                const oldIndex = parseInt(level.id.replace('level-', ''));
                const newIndex = index;
                const correctLevelNumber = index + 1;
                
                // Update level ID
                level.id = `level-${newIndex}`;
                
                // Update level body ID
                const levelBody = level.querySelector('[id^="level-body-"]');
                if (levelBody) {
                    levelBody.id = `level-body-${newIndex}`;
                }
                
                // Update attacks container ID
                const attacksContainer = level.querySelector('[id^="attacks-"]');
                if (attacksContainer) {
                    attacksContainer.id = `attacks-${newIndex}`;
                }
                
                // Update the level number in the header
                const header = level.querySelector('header strong');
                if (header) {
                    header.textContent = `Level ${correctLevelNumber}`;
                }
                
                // Update all form field names within this level
                level.querySelectorAll('[name]').forEach(input => {
                    if (input.name && input.name.includes(`level[${oldIndex}]`)) {
                        input.name = input.name.replace(`level[${oldIndex}]`, `level[${newIndex}]`);
                    }
                });
                
                // Update all IDs within this level
                level.querySelectorAll('[id]').forEach(el => {
                    if (el.id && el !== level) {
                        el.id = el.id.replace(new RegExp(`-${oldIndex}(-|$)`), `-${newIndex}$1`);
                    }
                });
                
                // Update onclick handlers for buttons within this level
                level.querySelectorAll('[onclick*="addAttack"], [onclick*="cloneAttack"], [onclick*="addDice"], [onclick*="removeAttack"], [onclick*="removeDice"], [onclick*="removeLevel"]').forEach(btn => {
                    const onclickStr = btn.getAttribute('onclick');
                    if (onclickStr) {
                        let updatedOnclick = onclickStr;
                        
                        // Update addAttack(oldIndex) -> addAttack(newIndex)
                        updatedOnclick = updatedOnclick.replace(new RegExp(`addAttack\\(${oldIndex}\\)`, 'g'), `addAttack(${newIndex})`);
                        
                        // Update cloneAttack(oldIndex) -> cloneAttack(newIndex)
                        updatedOnclick = updatedOnclick.replace(new RegExp(`cloneAttack\\(${oldIndex}\\)`, 'g'), `cloneAttack(${newIndex})`);
                        
                        // Update addDice(oldIndex, ...) -> addDice(newIndex, ...)
                        updatedOnclick = updatedOnclick.replace(new RegExp(`addDice\\(${oldIndex},`, 'g'), `addDice(${newIndex},`);
                        
                        // Update removeAttack('attack-oldIndex-...') -> removeAttack('attack-newIndex-...')
                        updatedOnclick = updatedOnclick.replace(new RegExp(`removeAttack\\('attack-${oldIndex}-`, 'g'), `removeAttack('attack-${newIndex}-`);
                        
                        // Update removeDice('dice-oldIndex-...') -> removeDice('dice-newIndex-...')
                        updatedOnclick = updatedOnclick.replace(new RegExp(`removeDice\\('dice-${oldIndex}-`, 'g'), `removeDice('dice-${newIndex}-`);
                        
                        // Update removeLevel('level-oldIndex') -> removeLevel('level-newIndex')
                        updatedOnclick = updatedOnclick.replace(new RegExp(`removeLevel\\('level-${oldIndex}'\\)`, 'g'), `removeLevel('level-${newIndex}')`);
                        
                        btn.setAttribute('onclick', updatedOnclick);
                    }
                });
                
                // Update data attributes and other level-specific references
                level.querySelectorAll('[data-collapse-target], [hx-target], [hx-delete]').forEach(el => {
                    ['data-collapse-target', 'hx-target', 'hx-delete'].forEach(attr => {
                        const value = el.getAttribute(attr);
                        if (value && value.includes(`-${oldIndex}-`)) {
                            el.setAttribute(attr, value.replace(`-${oldIndex}-`, `-${newIndex}-`));
                        }
                    });
                });
                
                // Update the hidden input value
                const levelNumberInput = level.querySelector('input[name$="].number"]');
                if (levelNumberInput) {
                    levelNumberInput.value = correctLevelNumber;
                }
            });
            
            // Hide clone button if no levels remain
            const cloneButtonSpan = document.getElementById('clone-level-btn');
            if (cloneButtonSpan && levels.length === 0) {
                cloneButtonSpan.innerHTML = '';
            }
        }

        // Remove level function - pure client-side
        function removeLevel(levelId) {
            const levelElement = document.getElementById(levelId);
            if (levelElement) {
                // Remove the level element
                levelElement.remove();
                
                // Renumber all remaining levels
                renumberAllLevels();
            }
        }

        // Remove attack function - pure client-side
        function removeAttack(attackId) {
            const attackElement = document.getElementById(attackId);
            if (attackElement) {
                const container = attackElement.parentElement;
                // Remove the attack element
                attackElement.remove();
                const levelMatch = container?.id.match(/^attacks-(\d+)$/);
                if (levelMatch) {
                    updateAttackOrderForLevel(parseInt(levelMatch[1], 10));
                }
            }
        }

        // Add dice function - pure client-side
        function addDice(levelIndex, attackIndex) {
            const container = document.getElementById(`dice-${levelIndex}-${attackIndex}`);
            if (!container) return;
            
            // Get current dice counter for unique IDs (monotonic)
            const diceCounter = document.getElementById('dice-counter');
            if (!diceCounter) return;
            
            const currentCounter = parseInt(diceCounter.value) || 0;
            const newDiceIndex = currentCounter;
            
            // Create new dice group HTML
            const diceId = `dice-${levelIndex}-${attackIndex}-${newDiceIndex}`;
            const prefix = `level[${levelIndex}].attacks[${attackIndex}].dice[${newDiceIndex}]`;
            
            const diceHtml = `
                <div id="${diceId}" class="grid" style="align-items:end;">
                    <div>
                        <label for="${prefix}.quantity">Qty</label>
                        <input type="number" name="${prefix}.quantity" value="1" min="1" max="99" required />
                    </div>
                    <div>
                        <label for="${prefix}.dieSize">Die</label>
                        <select name="${prefix}.dieSize">
                            <option value="4">d4</option>
                            <option value="6" selected>d6</option>
                            <option value="8">d8</option>
                            <option value="10">d10</option>
                            <option value="12">d12</option>
                            <option value="20">d20</option>
                        </select>
                    </div>
                    <div>
                        <button type="button"
                                onclick="removeDice('${diceId}')"
                                class="outline secondary btn-sm"
                                style="margin-bottom:0;">
                            X
                        </button>
                    </div>
                </div>
            `;
            
            // Add to container
            container.insertAdjacentHTML('beforeend', diceHtml);
            
            // Update counter
            diceCounter.value = currentCounter + 1;
        }

        // Remove dice function - pure client-side
        function removeDice(diceId) {
            const diceElement = document.getElementById(diceId);
            if (diceElement) {
                // Remove the dice element
                diceElement.remove();
            }
        }

        // Template caching for JavaScript attack creation
        let emptyAttackTemplate = null;

        function initializeAttackTemplate() {
            // Create a temporary empty attack to use as template
            if (emptyAttackTemplate) return;
            
            // Use the server-rendered template structure
            emptyAttackTemplate = `
                <fieldset id="ATTACK_ID_PLACEHOLDER"
                          class="attack-draggable"
                          draggable="true"
                          ondragstart="onAttackDragStart(event)"
                          ondragover="onAttackDragOver(event)"
                          ondragleave="onAttackDragLeave(event)"
                          ondrop="onAttackDrop(event)"
                          ondragend="onAttackDragEnd(event)">
                    <legend style="display:flex;align-items:center;gap:0.5rem;">
                        <button type="button" class="outline secondary btn-sm drag-handle" title="Drag to reorder">&#x2630;</button>
                        <button type="button"
                                data-collapse-target="ATTACK_BODY_ID_PLACEHOLDER"
                                onclick="toggleSectionById(this)"
                                class="outline secondary btn-sm">&#x25BE;</button>
                        New Attack
                    </legend>

                    <div id="ATTACK_BODY_ID_PLACEHOLDER">
                        <input type="hidden" name="ATTACK_PREFIX_PLACEHOLDER.order" value="ATTACK_INDEX_PLACEHOLDER" />
                        <div class="grid">
                            <div>
                                <label for="ATTACK_PREFIX_PLACEHOLDER.name">Attack Name</label>
                                <input type="text" name="ATTACK_PREFIX_PLACEHOLDER.name" value="" required placeholder="e.g. Longsword" />
                            </div>
                            <div>
                                <label for="ATTACK_PREFIX_PLACEHOLDER.actionType">Attack Type</label>
                                <select name="ATTACK_PREFIX_PLACEHOLDER.actionType" required
                                        onchange="this.closest('fieldset').querySelector('.reaction-chance').style.display=(this.value==='reaction'||this.value==='bonus_action')?'block':'none'">
                                    <option value="action" selected>Action Attack</option>
                                    <option value="bonus_action">Bonus Action Attack</option>
                                    <option value="reaction">Reaction Attack</option>
                                </select>
                            </div>
                        </div>
                        <div class="reaction-chance" style="display:none;">
                            <label for="ATTACK_PREFIX_PLACEHOLDER.reactionChancePercent">Trigger %</label>
                            <input type="number" name="ATTACK_PREFIX_PLACEHOLDER.reactionChancePercent" value="100" min="0" max="100" />
                        </div>

                        <div class="grid">
                            <div>
                                <label for="ATTACK_PREFIX_PLACEHOLDER.hitPercent">Hit %</label>
                                <input type="number" name="ATTACK_PREFIX_PLACEHOLDER.hitPercent" value="0" min="0" max="100"
                                       hx-post="/character/validate-percentages"
                                       hx-trigger="change"
                                       hx-target="#pct-error-LEVEL_INDEX_PLACEHOLDER-ATTACK_INDEX_PLACEHOLDER"
                                       hx-swap="innerHTML"
                                       hx-include="[name='ATTACK_PREFIX_PLACEHOLDER.hitPercent'],[name='ATTACK_PREFIX_PLACEHOLDER.critPercent']" />
                            </div>
                            <div>
                                <label for="ATTACK_PREFIX_PLACEHOLDER.critPercent">Crit %</label>
                                <input type="number" name="ATTACK_PREFIX_PLACEHOLDER.critPercent" value="0" min="0" max="100"
                                       hx-post="/character/validate-percentages"
                                       hx-trigger="change"
                                       hx-target="#pct-error-LEVEL_INDEX_PLACEHOLDER-ATTACK_INDEX_PLACEHOLDER"
                                       hx-swap="innerHTML"
                                       hx-include="[name='ATTACK_PREFIX_PLACEHOLDER.hitPercent'],[name='ATTACK_PREFIX_PLACEHOLDER.critPercent']" />
                            </div>
                        </div>
                        <small id="pct-error-LEVEL_INDEX_PLACEHOLDER-ATTACK_INDEX_PLACEHOLDER" style="color:var(--pico-del-color);"></small>

                        <div class="grid">
                            <div>
                                <label><input type="checkbox" name="ATTACK_PREFIX_PLACEHOLDER.masteryVex" /> Vex</label>
                            </div>
                            <div>
                                <label><input type="checkbox" name="ATTACK_PREFIX_PLACEHOLDER.masteryTopple"
                                       onchange="this.closest('fieldset').querySelector('.topple-pct').style.display=this.checked?'block':'none'" /> Topple</label>
                            </div>
                            <div>
                                <label><input type="checkbox" name="ATTACK_PREFIX_PLACEHOLDER.masteryGraze"
                                       onchange="this.closest('fieldset').querySelector('.graze-value').style.display=this.checked?'block':'none'" /> Graze</label>
                            </div>
                            <div>
                                <label title="Cannot be used in round 1 of a combat.">
                                    <input type="checkbox" name="ATTACK_PREFIX_PLACEHOLDER.requiresSetup" /> Requires setup
                                </label>
                            </div>
                        </div>
                        <div class="topple-pct" style="display:none;">
                            <label for="ATTACK_PREFIX_PLACEHOLDER.topplePercent">Topple Save Fail %</label>
                            <input type="number" name="ATTACK_PREFIX_PLACEHOLDER.topplePercent" value="0" min="0" max="100" placeholder="e.g. 40" />
                        </div>
                        <div class="graze-value" style="display:none;">
                            <label for="ATTACK_PREFIX_PLACEHOLDER.grazeValue">Graze Damage</label>
                            <input type="number" name="ATTACK_PREFIX_PLACEHOLDER.grazeValue" value="0" min="0" placeholder="e.g. 2" />
                        </div>

                        <h6>Damage</h6>
                        <div id="dice-LEVEL_INDEX_PLACEHOLDER-ATTACK_INDEX_PLACEHOLDER">
                            <!-- Empty dice container -->
                        </div>

                        <button type="button"
                                onclick="addDice(LEVEL_INDEX_PLACEHOLDER, ATTACK_INDEX_PLACEHOLDER)"
                                class="outline btn-sm">
                            + Add Dice
                        </button>

                        <div style="margin-top:1rem;">
                            <label for="ATTACK_PREFIX_PLACEHOLDER.flatModifier">Damage Modifier (+/-)</label>
                            <input type="number" name="ATTACK_PREFIX_PLACEHOLDER.flatModifier" value="0" placeholder="e.g. 5 for +5" />
                        </div>

                        <div class="attack-actions">
                            <button type="button"
                                    onclick="removeAttack('ATTACK_ID_PLACEHOLDER')"
                                    class="outline secondary btn-sm">
                                Remove Attack
                            </button>
                        </div>
                    </div>
                </fieldset>
            `;
        }

        // Add attack function - pure client-side
        function addAttack(levelIndex) {
            const container = document.getElementById(`attacks-${levelIndex}`);
            if (!container) return;
            
            // Initialize template if not already done
            initializeAttackTemplate();
            
            // Get current attack counter and increment
            const attackCounter = document.getElementById('attack-counter');
            const currentCounter = parseInt(attackCounter.value) || 0;
            const newAttackIndex = currentCounter;
            
            // Create new attack HTML by replacing placeholders
            const attackId = `attack-${levelIndex}-${newAttackIndex}`;
            const attackBodyId = `attack-body-${levelIndex}-${newAttackIndex}`;
            const attackPrefix = `level[${levelIndex}].attacks[${newAttackIndex}]`;
            
            let attackHtml = emptyAttackTemplate
                .replace(/ATTACK_ID_PLACEHOLDER/g, attackId)
                .replace(/ATTACK_BODY_ID_PLACEHOLDER/g, attackBodyId)
                .replace(/ATTACK_PREFIX_PLACEHOLDER/g, attackPrefix)
                .replace(/LEVEL_INDEX_PLACEHOLDER/g, levelIndex.toString())
                .replace(/ATTACK_INDEX_PLACEHOLDER/g, newAttackIndex.toString());
            
            // Create a temporary div to hold the HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = attackHtml;
            const newAttack = tempDiv.firstElementChild;
            
            // Update the attack counter
            attackCounter.value = newAttackIndex + 1;
            
            // Append to container
            container.appendChild(newAttack);
            updateAttackOrderForLevel(levelIndex);
             
            // Process HTMX attributes on the new element
            htmx.process(newAttack);
        }

        // Clone level function - pure client-side
        function cloneLevel() {
            const container = document.getElementById('levels-container');
            if (!container) return;
            
            const levels = container.querySelectorAll('article');
            if (levels.length === 0) return;
            
            // Clone the last level
            const lastLevel = levels[levels.length - 1];
            const cloned = lastLevel.cloneNode(true);
            copyFormControlState(lastLevel, cloned);
            
            // Extract old level index from id
            const oldIndex = parseInt(lastLevel.id.replace('level-', '')) || (levels.length - 1);
            
            // Get current counter and calculate new index
            const levelCounter = document.getElementById('level-counter');
            const newIndex = parseInt(levelCounter.value) || levels.length;
            
            // Calculate new level number (increment from last level's number)
            const lastLevelNumberInput = lastLevel.querySelector(`input[name="level[${oldIndex}].number"]`);
            const lastLevelNumber = lastLevelNumberInput ? parseInt(lastLevelNumberInput.value) : oldIndex + 1;
            const newLevelNumber = lastLevelNumber + 1;
            
            if (newLevelNumber > 20) {
                alert('Maximum level is 20');
                return;
            }
            
            // Update level number in header
            const header = cloned.querySelector('header strong');
            if (header) {
                header.textContent = `Level ${newLevelNumber}`;
            }
            
            // Update hidden level number input
            const levelNumberInput = cloned.querySelector(`input[name^="level["]`);
            if (levelNumberInput) {
                levelNumberInput.name = `level[${newIndex}].number`;
                levelNumberInput.value = newLevelNumber;
            }
            
            // Update article id
            cloned.id = `level-${newIndex}`;
            
            // Update all name attributes: level[oldIndex] -> level[newIndex]
            cloned.querySelectorAll('[name]').forEach(input => {
                if (input.name && input.name.includes(`level[${oldIndex}]`)) {
                    input.name = input.name.replace(
                        `level[${oldIndex}]`,
                        `level[${newIndex}]`
                    );
                }
            });
            
            // Update all id attributes with old level index
            cloned.querySelectorAll('[id]').forEach(el => {
                if (el.id) {
                    // Update patterns like: level-body-0, attacks-0, attack-0-*, dice-0-*-*
                    el.id = el.id.replace(
                        new RegExp(`-(${oldIndex})(-|$)`, 'g'),
                        `-${newIndex}$2`
                    );
                }
            });
            
            // Update HTMX attributes with level index
            cloned.querySelectorAll('[hx-target]').forEach(el => {
                const target = el.getAttribute('hx-target');
                if (target) {
                    el.setAttribute('hx-target', target.replace(
                        new RegExp(`-(${oldIndex})(-|$)`, 'g'),
                        `-${newIndex}$2`
                    ));
                }
            });
            
            cloned.querySelectorAll('[hx-delete]').forEach(el => {
                const url = el.getAttribute('hx-delete');
                if (url) {
                    el.setAttribute('hx-delete', url.replace(
                        `index=${oldIndex}`,
                        `index=${newIndex}`
                    ));
                }
            });
            
            // Update onclick handlers for buttons within this cloned level
            cloned.querySelectorAll('[onclick*="addAttack"], [onclick*="cloneAttack"], [onclick*="addDice"], [onclick*="removeAttack"], [onclick*="removeDice"], [onclick*="removeLevel"]').forEach(btn => {
                const onclickStr = btn.getAttribute('onclick');
                if (onclickStr) {
                    let updatedOnclick = onclickStr;
                    
                    // Update addAttack(oldIndex) -> addAttack(newIndex)
                    updatedOnclick = updatedOnclick.replace(new RegExp(`addAttack\\(${oldIndex}\\)`, 'g'), `addAttack(${newIndex})`);
                    
                    // Update cloneAttack(oldIndex) -> cloneAttack(newIndex)
                    updatedOnclick = updatedOnclick.replace(new RegExp(`cloneAttack\\(${oldIndex}\\)`, 'g'), `cloneAttack(${newIndex})`);
                    
                    // Update addDice(oldIndex, ...) -> addDice(newIndex, ...)
                    updatedOnclick = updatedOnclick.replace(new RegExp(`addDice\\(${oldIndex},`, 'g'), `addDice(${newIndex},`);
                    
                    // Update removeAttack('attack-oldIndex-...') -> removeAttack('attack-newIndex-...')
                    updatedOnclick = updatedOnclick.replace(new RegExp(`removeAttack\\('attack-${oldIndex}-`, 'g'), `removeAttack('attack-${newIndex}-`);
                    
                    // Update removeDice('dice-oldIndex-...') -> removeDice('dice-newIndex-...')
                    updatedOnclick = updatedOnclick.replace(new RegExp(`removeDice\\('dice-${oldIndex}-`, 'g'), `removeDice('dice-${newIndex}-`);
                    
                    // Update removeLevel('level-oldIndex') -> removeLevel('level-newIndex')
                    updatedOnclick = updatedOnclick.replace(new RegExp(`removeLevel\\('level-${oldIndex}'\\)`, 'g'), `removeLevel('level-${newIndex}')`);
                    
                    btn.setAttribute('onclick', updatedOnclick);
                }
            });
            
            cloned.querySelectorAll('[hx-post]').forEach(el => {
                const url = el.getAttribute('hx-post');
                if (url) {
                    el.setAttribute('hx-post', url.replace(
                        `levelIndex=${oldIndex}`,
                        `levelIndex=${newIndex}`
                    ));
                }
            });
            
            cloned.querySelectorAll('[data-collapse-target]').forEach(el => {
                const targetId = el.getAttribute('data-collapse-target');
                if (targetId) {
                    el.setAttribute('data-collapse-target', targetId.replace(
                        new RegExp(`-(${oldIndex})(-|$)`, 'g'),
                        `-${newIndex}$2`
                    ));
                }
            });

            cloned.querySelectorAll('[data-collapse-target]').forEach(toggle => {
                const targetId = toggle.getAttribute('data-collapse-target');
                if (!targetId) return;

                const target = cloned.querySelector(`[id="${targetId}"]`);
                if (target) {
                    target.style.display = '';
                }

                toggle.textContent = '\u25BE';
            });
            
            // Update counters
            levelCounter.value = newIndex + 1;
            
            // Update attack counter if needed (count all attacks in cloned level)
            const attackCounter = document.getElementById('attack-counter');
            const clonedAttacks = cloned.querySelectorAll('fieldset[id^="attack-"]');
            const currentAttackCounter = parseInt(attackCounter.value) || 0;
            attackCounter.value = Math.max(currentAttackCounter, clonedAttacks.length);
            
            // Update dice counter if needed (count all dice groups in cloned level)
            const diceCounter = document.getElementById('dice-counter');
            const clonedDice = cloned.querySelectorAll('[id^="dice-"]');
            const currentDiceCounter = parseInt(diceCounter.value) || 0;
            diceCounter.value = Math.max(currentDiceCounter, clonedDice.length);
            
            // Append to container
            container.appendChild(cloned);
            
            // Process HTMX attributes on the new element
            htmx.process(cloned);
        }
    </script>
</body>
</html>
