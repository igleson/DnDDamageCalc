<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>"D&D Damage Calculator"</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
    <link rel="stylesheet" href="/style.css" />
    <script src="https://unpkg.com/htmx.org@2.0.4"
            integrity="sha384-HGfztofotfshcF7+8n44JQL2oJmowVChPTg48S+jvZoztPfvwD79OC/LTtG6dMp+"
            crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
        }
        .app-layout {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            min-width: 280px;
            background: var(--pico-card-background-color);
            border-right: 1px solid var(--pico-muted-border-color);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            transition: margin-left 0.25s ease;
            overflow-y: auto;
        }
        .sidebar.collapsed {
            margin-left: -280px;
        }
        .sidebar h4 {
            margin-bottom: 0.5rem;
        }
        .sidebar hr {
            margin: 0.75rem 0;
        }
        #character-list {
            flex: 1;
            overflow-y: auto;
        }

        /* Toggle button */
        .sidebar-toggle {
            position: fixed;
            top: 0.75rem;
            left: 0.75rem;
            z-index: 10;
            width: auto !important;
            padding: 0.35rem 0.65rem !important;
            margin: 0 !important;
            font-size: 1.2rem;
            line-height: 1;
            transition: left 0.25s ease;
        }
        .sidebar:not(.collapsed) ~ .app-main .sidebar-toggle {
            left: 290px;
        }

        /* Main content */
        .app-main {
            flex: 1;
            min-width: 0;
            padding: 1rem 2rem;
            max-width: 900px;
            overflow-y: auto;
        }
        header.app-header {
            text-align: center;
            padding: 1rem 0;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--pico-muted-border-color);
        }
        header.app-header h1 {
            margin-bottom: 0.25rem;
        }
        header.app-header small {
            color: var(--pico-muted-color);
        }

        /* Form styles */
        #form-container fieldset {
            border: 1px solid var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            padding: 1rem;
            margin-bottom: 1rem;
        }
        #form-container fieldset legend {
            font-weight: bold;
            padding: 0 0.5rem;
        }
        .attack-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .btn-sm {
            width: auto !important;
            margin: 0 !important;
            padding: 0.25rem 0.75rem !important;
        }

        /* Sidebar character items */
        .char-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            border-radius: var(--pico-border-radius);
            margin-bottom: 0.25rem;
        }
        .char-item:hover {
            background: var(--pico-secondary-hover-background);
        }
        .char-item a {
            flex: 1;
            text-decoration: none;
        }

        /* Responsive: stack on small screens */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                z-index: 5;
                box-shadow: 2px 0 8px rgba(0,0,0,0.3);
            }
            .sidebar.collapsed {
                margin-left: -280px;
            }
            .sidebar-toggle {
                left: 0.75rem !important;
            }
            .sidebar:not(.collapsed) ~ .app-main .sidebar-toggle {
                left: 290px !important;
            }
            .app-main {
                padding: 1rem;
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <aside class="sidebar" id="sidebar">
            <h4>Characters</h4>
            <hr />
            <div id="character-list">
                {{ character_list.html }}
            </div>
            <hr />
            <button type="button" class="outline"
                    hx-get="/character/form"
                    hx-target="#form-container"
                    hx-swap="innerHTML"
                    style="width:100%;">
                + New Character
            </button>
            {{ if show_logout }}
            <hr />
            <form method="post" action="/auth/logout">
                <button type="submit" class="outline secondary" style="width:100%;">Logout</button>
            </form>
            {{ end }}
        </aside>

        <div class="app-main">
            <button type="button" class="sidebar-toggle outline secondary"
                    onclick="document.getElementById('sidebar').classList.toggle('collapsed')">
                &#9776;
            </button>

            <header class="app-header">
                <h1>D&D Damage Calculator</h1>
                <small>Build your character, calculate your damage</small>
            </header>

            <div id="messages"></div>

            <div id="form-container">
                {{ character_form.html }}
            </div>
        </div>
    </div>
    <script>
        function graphContainerFromElement(element) {
            return element.closest('[data-damage-graph]');
        }

        function toggleSectionById(button) {
            const targetId = button.getAttribute('data-collapse-target');
            if (!targetId) return;

            const target = document.getElementById(targetId);
            if (!target) return;

            const shouldExpand = target.style.display === 'none';
            target.style.display = shouldExpand ? '' : 'none';
            button.textContent = shouldExpand ? '\u25BE' : '\u25B8';
        }

        function moveDamageTooltip(event) {
            const point = event.currentTarget;
            const graph = graphContainerFromElement(point);
            if (!graph) return;

            const tooltip = graph.querySelector('[data-damage-tooltip]');
            if (!tooltip || tooltip.dataset.visible !== 'true') return;

            const graphRect = graph.getBoundingClientRect();
            let left = event.clientX - graphRect.left + 12;
            let top = event.clientY - graphRect.top - 30;

            const maxLeft = graph.clientWidth - tooltip.offsetWidth - 8;
            const maxTop = graph.clientHeight - tooltip.offsetHeight - 8;
            left = Math.max(8, Math.min(left, maxLeft));
            top = Math.max(8, Math.min(top, maxTop));

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        function showDamageTooltip(event) {
            const point = event.currentTarget;
            const graph = graphContainerFromElement(point);
            if (!graph) return;

            const tooltip = graph.querySelector('[data-damage-tooltip]');
            if (!tooltip) return;

            const stat = point.getAttribute('data-stat-label');
            const level = point.getAttribute('data-level');
            const damage = point.getAttribute('data-damage');
            tooltip.textContent = `${stat} - Level ${level}: ${damage}`;
            tooltip.dataset.series = point.getAttribute('data-series') || '';
            tooltip.dataset.visible = 'true';
            tooltip.style.display = 'block';
            moveDamageTooltip(event);
        }

        function hideDamageTooltip(element) {
            const graph = graphContainerFromElement(element);
            if (!graph) return;

            const tooltip = graph.querySelector('[data-damage-tooltip]');
            if (!tooltip) return;

            tooltip.dataset.visible = 'false';
            tooltip.dataset.series = '';
            tooltip.style.display = 'none';
        }

        function toggleDamageSeries(toggle) {
            const graph = toggle.closest('[data-damage-graph]');
            if (!graph) return;

            const key = toggle.getAttribute('data-series-toggle');
            if (!key) return;

            graph.querySelectorAll(`[data-series="${key}"]`).forEach(el => {
                el.style.display = toggle.checked ? '' : 'none';
            });

            if (!toggle.checked) {
                const tooltip = graph.querySelector('[data-damage-tooltip]');
                if (tooltip && tooltip.dataset.series === key) {
                    hideDamageTooltip(toggle);
                }
            }
        }

        // Handle 401 unauthorized responses
        document.addEventListener('htmx:responseError', function(e) {
            if (e.detail.xhr.status === 401) window.location.href = '/login';
        });

        // Track selected character in sidebar
        document.addEventListener('htmx:beforeRequest', function(evt) {
            const target = evt.detail.elt;
            
            // If clicking a character link
            if (target.hasAttribute('hx-get') && target.getAttribute('hx-get').startsWith('/character/')) {
                const charItem = target.closest('.char-item');
                if (charItem) {
                    // Remove selected class from all items
                    document.querySelectorAll('.char-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    // Add selected class to clicked item
                    charItem.classList.add('selected');
                }
            }
            
            // If clicking "New Character" button
            if (target.hasAttribute('hx-get') && target.getAttribute('hx-get') === '/character/form') {
                // Remove selected class from all character items
                document.querySelectorAll('.char-item').forEach(item => {
                    item.classList.remove('selected');
                });
            }
        });

        // Clone attack function - pure client-side
        function cloneAttack(levelIndex) {
            const container = document.getElementById(`attacks-${levelIndex}`);
            if (!container) return;
            
            const attacks = container.querySelectorAll('fieldset');
            if (attacks.length === 0) return;
            
            // Clone the last attack
            const lastAttack = attacks[attacks.length - 1];
            const cloned = lastAttack.cloneNode(true);
            
            // Get current counter and increment
            const counterInput = document.getElementById('attack-counter');
            const currentCounter = parseInt(counterInput.value) || attacks.length;
            const newIndex = currentCounter;
            cloned.id = `attack-${levelIndex}-${newIndex}`;
            
            // Find the old attack index from the last attack's id attribute
            const lastAttackId = lastAttack.id;
            const oldIndexMatch = lastAttackId.match(/attack-\d+-(\d+)$/);
            const oldIndex = oldIndexMatch ? parseInt(oldIndexMatch[1]) : attacks.length - 1;
            
            // Update all name attributes: attacks[oldIndex] -> attacks[newIndex]
            cloned.querySelectorAll('[name]').forEach(input => {
                if (input.name) {
                    input.name = input.name.replace(
                        `attacks[${oldIndex}]`, 
                        `attacks[${newIndex}]`
                    );
                }
            });
            
            // Update all id attributes: attack-{level}-{oldIndex} -> attack-{level}-{newIndex}
            cloned.querySelectorAll('[id]').forEach(el => {
                if (el.id) {
                    el.id = el.id.replace(
                        new RegExp(`-${levelIndex}-${oldIndex}(-|$)`, 'g'),
                        `-${levelIndex}-${newIndex}$1`
                    );
                }
            });
            
            // Update HTMX attributes (hx-target, hx-delete, hx-post)
            cloned.querySelectorAll('[hx-target]').forEach(el => {
                const target = el.getAttribute('hx-target');
                if (target) {
                    el.setAttribute('hx-target', target.replace(
                        `-${levelIndex}-${oldIndex}`,
                        `-${levelIndex}-${newIndex}`
                    ));
                }
            });
            
            cloned.querySelectorAll('[hx-delete]').forEach(el => {
                const url = el.getAttribute('hx-delete');
                if (url) {
                    el.setAttribute('hx-delete', url.replace(
                        `attackIndex=${oldIndex}`,
                        `attackIndex=${newIndex}`
                    ));
                }
            });
            
            cloned.querySelectorAll('[hx-post]').forEach(el => {
                const url = el.getAttribute('hx-post');
                if (url) {
                    el.setAttribute('hx-post', url.replace(
                        `attackIndex=${oldIndex}`,
                        `attackIndex=${newIndex}`
                    ));
                }
            });

            cloned.querySelectorAll('[data-collapse-target]').forEach(el => {
                const targetId = el.getAttribute('data-collapse-target');
                if (targetId) {
                    el.setAttribute('data-collapse-target', targetId.replace(
                        `-${levelIndex}-${oldIndex}`,
                        `-${levelIndex}-${newIndex}`
                    ));
                }
            });

            cloned.querySelectorAll('[data-collapse-target]').forEach(toggle => {
                const targetId = toggle.getAttribute('data-collapse-target');
                if (!targetId) return;

                const target = cloned.querySelector(`[id="${targetId}"]`);
                if (target) {
                    target.style.display = '';
                }

                toggle.textContent = '\u25BE';
            });
            
            // Update the counter
            counterInput.value = newIndex + 1;
            
            // Append to container
            container.appendChild(cloned);
            
            // Process HTMX attributes on the new element
            htmx.process(cloned);
        }

        // Clone level function - pure client-side
        function cloneLevel() {
            const container = document.getElementById('levels-container');
            if (!container) return;
            
            const levels = container.querySelectorAll('article');
            if (levels.length === 0) return;
            
            // Clone the last level
            const lastLevel = levels[levels.length - 1];
            const cloned = lastLevel.cloneNode(true);
            
            // Extract old level index from id
            const oldIndex = parseInt(lastLevel.id.replace('level-', '')) || (levels.length - 1);
            
            // Get current counter and calculate new index
            const levelCounter = document.getElementById('level-counter');
            const newIndex = parseInt(levelCounter.value) || levels.length;
            
            // Calculate new level number (increment from last level's number)
            const lastLevelNumberInput = lastLevel.querySelector(`input[name="level[${oldIndex}].number"]`);
            const lastLevelNumber = lastLevelNumberInput ? parseInt(lastLevelNumberInput.value) : oldIndex + 1;
            const newLevelNumber = lastLevelNumber + 1;
            
            if (newLevelNumber > 20) {
                alert('Maximum level is 20');
                return;
            }
            
            // Update level number in header
            const header = cloned.querySelector('header strong');
            if (header) {
                header.textContent = `Level ${newLevelNumber}`;
            }
            
            // Update hidden level number input
            const levelNumberInput = cloned.querySelector(`input[name^="level["]`);
            if (levelNumberInput) {
                levelNumberInput.name = `level[${newIndex}].number`;
                levelNumberInput.value = newLevelNumber;
            }
            
            // Update article id
            cloned.id = `level-${newIndex}`;
            
            // Update all name attributes: level[oldIndex] -> level[newIndex]
            cloned.querySelectorAll('[name]').forEach(input => {
                if (input.name && input.name.includes(`level[${oldIndex}]`)) {
                    input.name = input.name.replace(
                        `level[${oldIndex}]`,
                        `level[${newIndex}]`
                    );
                }
            });
            
            // Update all id attributes with old level index
            cloned.querySelectorAll('[id]').forEach(el => {
                if (el.id) {
                    // Update patterns like: level-body-0, attacks-0, attack-0-*, dice-0-*-*
                    el.id = el.id.replace(
                        new RegExp(`-(${oldIndex})(-|$)`, 'g'),
                        `-${newIndex}$2`
                    );
                }
            });
            
            // Update HTMX attributes with level index
            cloned.querySelectorAll('[hx-target]').forEach(el => {
                const target = el.getAttribute('hx-target');
                if (target) {
                    el.setAttribute('hx-target', target.replace(
                        new RegExp(`-(${oldIndex})(-|$)`, 'g'),
                        `-${newIndex}$2`
                    ));
                }
            });
            
            cloned.querySelectorAll('[hx-delete]').forEach(el => {
                const url = el.getAttribute('hx-delete');
                if (url) {
                    el.setAttribute('hx-delete', url.replace(
                        `index=${oldIndex}`,
                        `index=${newIndex}`
                    ));
                }
            });
            
            cloned.querySelectorAll('[hx-post]').forEach(el => {
                const url = el.getAttribute('hx-post');
                if (url) {
                    el.setAttribute('hx-post', url.replace(
                        `levelIndex=${oldIndex}`,
                        `levelIndex=${newIndex}`
                    ));
                }
            });
            
            cloned.querySelectorAll('[data-collapse-target]').forEach(el => {
                const targetId = el.getAttribute('data-collapse-target');
                if (targetId) {
                    el.setAttribute('data-collapse-target', targetId.replace(
                        new RegExp(`-(${oldIndex})(-|$)`, 'g'),
                        `-${newIndex}$2`
                    ));
                }
            });

            cloned.querySelectorAll('[data-collapse-target]').forEach(toggle => {
                const targetId = toggle.getAttribute('data-collapse-target');
                if (!targetId) return;

                const target = cloned.querySelector(`[id="${targetId}"]`);
                if (target) {
                    target.style.display = '';
                }

                toggle.textContent = '\u25BE';
            });
            
            // Update counters
            levelCounter.value = newIndex + 1;
            
            // Update attack counter if needed (count all attacks in cloned level)
            const attackCounter = document.getElementById('attack-counter');
            const clonedAttacks = cloned.querySelectorAll('fieldset[id^="attack-"]');
            const currentAttackCounter = parseInt(attackCounter.value) || 0;
            attackCounter.value = Math.max(currentAttackCounter, clonedAttacks.length);
            
            // Update dice counter if needed (count all dice groups in cloned level)
            const diceCounter = document.getElementById('dice-counter');
            const clonedDice = cloned.querySelectorAll('[id^="dice-"]');
            const currentDiceCounter = parseInt(diceCounter.value) || 0;
            diceCounter.value = Math.max(currentDiceCounter, clonedDice.length);
            
            // Append to container
            container.appendChild(cloned);
            
            // Process HTMX attributes on the new element
            htmx.process(cloned);
        }
    </script>
</body>
</html>